<?xml version="1.0"?>
<doc>
  <assembly>
    <name>HelloWorld.Domain.Host.Web</name>
  </assembly>
  <members>
    <member name="M:HelloWorld.Domain.Host.Web.NinjectWebCommon.Start">
      <summary>
            Starts the application
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.NinjectWebCommon.Stop">
      <summary>
            Stops the application.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.NinjectWebCommon.CreateKernel">
      <summary>
            Creates the kernel that will manage your application.
            </summary>
      <returns>The created kernel.</returns>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.NinjectWebCommon.RegisterServices(Ninject.IKernel)">
      <summary>
            Load your modules or register your services here!
            </summary>
      <param name="kernel">The kernel.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.ApiDescriptionExtensions.GetFriendlyId(System.Web.Http.Description.ApiDescription)">
      <summary>
            Generates an URI-friendly ID for the <see cref="T:System.Web.Http.Description.ApiDescription" />. E.g. "Get-Values-id_name" instead of "GetValues/{id}?name={name}"
            </summary>
      <param name="description">The <see cref="T:System.Web.Http.Description.ApiDescription" />.</param>
      <returns>The ID as a string.</returns>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfig">
      <summary>
            Use this class to customize the Help Page.
            For example you can set a custom <see cref="T:System.Web.Http.Description.IDocumentationProvider" /> to supply the documentation
            or you can provide the samples for the requests/responses.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.Controllers.HelpController">
      <summary>
            The controller that will handle requests for the help page.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetDocumentationProvider(System.Web.Http.HttpConfiguration,System.Web.Http.Description.IDocumentationProvider)">
      <summary>
            Sets the documentation provider for help page.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="documentationProvider">The documentation provider.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetSampleObjects(System.Web.Http.HttpConfiguration,System.Collections.Generic.IDictionary{System.Type,System.Object})">
      <summary>
            Sets the objects that will be used by the formatters to produce sample requests/responses.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="sampleObjects">The sample objects.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetSampleRequest(System.Web.Http.HttpConfiguration,System.Object,System.Net.Http.Headers.MediaTypeHeaderValue,System.String,System.String)">
      <summary>
            Sets the sample request directly for the specified media type and action.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="sample">The sample request.</param>
      <param name="mediaType">The media type.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetSampleRequest(System.Web.Http.HttpConfiguration,System.Object,System.Net.Http.Headers.MediaTypeHeaderValue,System.String,System.String,System.String[])">
      <summary>
            Sets the sample request directly for the specified media type and action with parameters.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="sample">The sample request.</param>
      <param name="mediaType">The media type.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
      <param name="parameterNames">The parameter names.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetSampleResponse(System.Web.Http.HttpConfiguration,System.Object,System.Net.Http.Headers.MediaTypeHeaderValue,System.String,System.String)">
      <summary>
            Sets the sample request directly for the specified media type of the action.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="sample">The sample response.</param>
      <param name="mediaType">The media type.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetSampleResponse(System.Web.Http.HttpConfiguration,System.Object,System.Net.Http.Headers.MediaTypeHeaderValue,System.String,System.String,System.String[])">
      <summary>
            Sets the sample response directly for the specified media type of the action with specific parameters.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="sample">The sample response.</param>
      <param name="mediaType">The media type.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
      <param name="parameterNames">The parameter names.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetSampleForMediaType(System.Web.Http.HttpConfiguration,System.Object,System.Net.Http.Headers.MediaTypeHeaderValue)">
      <summary>
            Sets the sample directly for all actions with the specified media type.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="sample">The sample.</param>
      <param name="mediaType">The media type.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetSampleForType(System.Web.Http.HttpConfiguration,System.Object,System.Net.Http.Headers.MediaTypeHeaderValue,System.Type)">
      <summary>
            Sets the sample directly for all actions with the specified type and media type.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="sample">The sample.</param>
      <param name="mediaType">The media type.</param>
      <param name="type">The parameter type or return type of an action.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetActualRequestType(System.Web.Http.HttpConfiguration,System.Type,System.String,System.String)">
      <summary>
            Specifies the actual type of <see cref="T:System.Net.Http.ObjectContent`1" /> passed to the <see cref="T:System.Net.Http.HttpRequestMessage" /> in an action.
            The help page will use this information to produce more accurate request samples.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="type">The type.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetActualRequestType(System.Web.Http.HttpConfiguration,System.Type,System.String,System.String,System.String[])">
      <summary>
            Specifies the actual type of <see cref="T:System.Net.Http.ObjectContent`1" /> passed to the <see cref="T:System.Net.Http.HttpRequestMessage" /> in an action.
            The help page will use this information to produce more accurate request samples.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="type">The type.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
      <param name="parameterNames">The parameter names.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetActualResponseType(System.Web.Http.HttpConfiguration,System.Type,System.String,System.String)">
      <summary>
            Specifies the actual type of <see cref="T:System.Net.Http.ObjectContent`1" /> returned as part of the <see cref="T:System.Net.Http.HttpRequestMessage" /> in an action.
            The help page will use this information to produce more accurate response samples.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="type">The type.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetActualResponseType(System.Web.Http.HttpConfiguration,System.Type,System.String,System.String,System.String[])">
      <summary>
            Specifies the actual type of <see cref="T:System.Net.Http.ObjectContent`1" /> returned as part of the <see cref="T:System.Net.Http.HttpRequestMessage" /> in an action.
            The help page will use this information to produce more accurate response samples.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="type">The type.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
      <param name="parameterNames">The parameter names.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.GetHelpPageSampleGenerator(System.Web.Http.HttpConfiguration)">
      <summary>
            Gets the help page sample generator.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <returns>The help page sample generator.</returns>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.SetHelpPageSampleGenerator(System.Web.Http.HttpConfiguration,HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator)">
      <summary>
            Sets the help page sample generator.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="sampleGenerator">The help page sample generator.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.GetModelDescriptionGenerator(System.Web.Http.HttpConfiguration)">
      <summary>
            Gets the model description generator.
            </summary>
      <param name="config">The configuration.</param>
      <returns>The <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ModelDescriptions.ModelDescriptionGenerator" /></returns>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageConfigurationExtensions.GetHelpPageApiModel(System.Web.Http.HttpConfiguration,System.String)">
      <summary>
            Gets the model that represents an API displayed on the help page. The model is initialized on the first call and cached for subsequent calls.
            </summary>
      <param name="config">The <see cref="T:System.Web.Http.HttpConfiguration" />.</param>
      <param name="apiDescriptionId">The <see cref="T:System.Web.Http.Description.ApiDescription" /> ID.</param>
      <returns>
            An <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel" /></returns>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ModelDescriptions.ModelDescription">
      <summary>
            Describes a type model.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ModelDescriptions.ModelDescriptionGenerator">
      <summary>
            Generates model descriptions for given types.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ModelDescriptions.ModelNameAttribute">
      <summary>
            Use this attribute to change the name of the <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ModelDescriptions.ModelDescription" /> generated for a type.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel">
      <summary>
            The model that represents an API displayed on the help page.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel" /> class.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.ApiDescription">
      <summary>
            Gets or sets the <see cref="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.ApiDescription" /> that describes the API.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.UriParameters">
      <summary>
            Gets or sets the <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ModelDescriptions.ParameterDescription" /> collection that describes the URI parameters for the API.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.RequestDocumentation">
      <summary>
            Gets or sets the documentation for the request.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.RequestModelDescription">
      <summary>
            Gets or sets the <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ModelDescriptions.ModelDescription" /> that describes the request body.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.RequestBodyParameters">
      <summary>
            Gets the request body parameter descriptions.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.ResourceDescription">
      <summary>
            Gets or sets the <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ModelDescriptions.ModelDescription" /> that describes the resource.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.ResourceProperties">
      <summary>
            Gets the resource property descriptions.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.SampleRequests">
      <summary>
            Gets the sample requests associated with the API.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.SampleResponses">
      <summary>
            Gets the sample responses associated with the API.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.Models.HelpPageApiModel.ErrorMessages">
      <summary>
            Gets the error messages associated with this model.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator">
      <summary>
            This class will generate the samples for the help page.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator" /> class.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.GetSampleRequests(System.Web.Http.Description.ApiDescription)">
      <summary>
            Gets the request body samples for a given <see cref="T:System.Web.Http.Description.ApiDescription" />.
            </summary>
      <param name="api">The <see cref="T:System.Web.Http.Description.ApiDescription" />.</param>
      <returns>The samples keyed by media type.</returns>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.GetSampleResponses(System.Web.Http.Description.ApiDescription)">
      <summary>
            Gets the response body samples for a given <see cref="T:System.Web.Http.Description.ApiDescription" />.
            </summary>
      <param name="api">The <see cref="T:System.Web.Http.Description.ApiDescription" />.</param>
      <returns>The samples keyed by media type.</returns>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.GetSample(System.Web.Http.Description.ApiDescription,HelloWorld.Domain.Host.Web.Areas.HelpPage.SampleDirection)">
      <summary>
            Gets the request or response body samples.
            </summary>
      <param name="api">The <see cref="T:System.Web.Http.Description.ApiDescription" />.</param>
      <param name="sampleDirection">The value indicating whether the sample is for a request or for a response.</param>
      <returns>The samples keyed by media type.</returns>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.GetActionSample(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Type,System.Net.Http.Formatting.MediaTypeFormatter,System.Net.Http.Headers.MediaTypeHeaderValue,HelloWorld.Domain.Host.Web.Areas.HelpPage.SampleDirection)">
      <summary>
            Search for samples that are provided directly through <see cref="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.ActionSamples" />.
            </summary>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
      <param name="parameterNames">The parameter names.</param>
      <param name="type">The CLR type.</param>
      <param name="formatter">The formatter.</param>
      <param name="mediaType">The media type.</param>
      <param name="sampleDirection">The value indicating whether the sample is for a request or for a response.</param>
      <returns>The sample that matches the parameters.</returns>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.GetSampleObject(System.Type)">
      <summary>
            Gets the sample object that will be serialized by the formatters. 
            First, it will look at the <see cref="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.SampleObjects" />. If no sample object is found, it will try to create
            one using <see cref="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.DefaultSampleObjectFactory(HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator,System.Type)" /> (which wraps an <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ObjectGenerator" />) and other
            factories in <see cref="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.SampleObjectFactories" />.
            </summary>
      <param name="type">The type.</param>
      <returns>The sample object.</returns>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.ResolveHttpRequestMessageType(System.Web.Http.Description.ApiDescription)">
      <summary>
            Resolves the actual type of <see cref="T:System.Net.Http.ObjectContent`1" /> passed to the <see cref="T:System.Net.Http.HttpRequestMessage" /> in an action.
            </summary>
      <param name="api">The <see cref="T:System.Web.Http.Description.ApiDescription" />.</param>
      <returns>The type.</returns>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.ResolveType(System.Web.Http.Description.ApiDescription,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},HelloWorld.Domain.Host.Web.Areas.HelpPage.SampleDirection,System.Collections.ObjectModel.Collection{System.Net.Http.Formatting.MediaTypeFormatter}@)">
      <summary>
            Resolves the type of the action parameter or return value when <see cref="T:System.Net.Http.HttpRequestMessage" /> or <see cref="T:System.Net.Http.HttpResponseMessage" /> is used.
            </summary>
      <param name="api">The <see cref="T:System.Web.Http.Description.ApiDescription" />.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
      <param name="parameterNames">The parameter names.</param>
      <param name="sampleDirection">The value indicating whether the sample is for a request or a response.</param>
      <param name="formatters">The formatters.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.WriteSampleObjectUsingFormatter(System.Net.Http.Formatting.MediaTypeFormatter,System.Object,System.Type,System.Net.Http.Headers.MediaTypeHeaderValue)">
      <summary>
            Writes the sample object using formatter.
            </summary>
      <param name="formatter">The formatter.</param>
      <param name="value">The value.</param>
      <param name="type">The type.</param>
      <param name="mediaType">Type of the media.</param>
      <returns>
      </returns>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.ActualHttpMessageTypes">
      <summary>
            Gets CLR types that are used as the content of <see cref="T:System.Net.Http.HttpRequestMessage" /> or <see cref="T:System.Net.Http.HttpResponseMessage" />.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.ActionSamples">
      <summary>
            Gets the objects that are used directly as samples for certain actions.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.SampleObjects">
      <summary>
            Gets the objects that are serialized as samples by the supported formatters.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleGenerator.SampleObjectFactories">
      <summary>
            Gets factories for the objects that the supported formatters will serialize as samples. Processed in order,
            stopping when the factory successfully returns a non-<see langref="null" /> object.
            </summary>
      <remarks>
            Collection includes just <see cref="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.ObjectGenerator.GenerateObject(System.Type)" /> initially. Use
            <code>SampleObjectFactories.Insert(0, func)</code> to provide an override and
            <code>SampleObjectFactories.Add(func)</code> to provide a fallback.</remarks>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey">
      <summary>
            This is used to identify the place where the sample should be applied.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.#ctor(System.Net.Http.Headers.MediaTypeHeaderValue)">
      <summary>
            Creates a new <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey" /> based on media type.
            </summary>
      <param name="mediaType">The media type.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.#ctor(System.Net.Http.Headers.MediaTypeHeaderValue,System.Type)">
      <summary>
            Creates a new <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey" /> based on media type and CLR type.
            </summary>
      <param name="mediaType">The media type.</param>
      <param name="type">The CLR type.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.#ctor(HelloWorld.Domain.Host.Web.Areas.HelpPage.SampleDirection,System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Creates a new <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey" /> based on <see cref="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.SampleDirection" />, controller name, action name and parameter names.
            </summary>
      <param name="sampleDirection">The <see cref="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.SampleDirection" />.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
      <param name="parameterNames">The parameter names.</param>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.#ctor(System.Net.Http.Headers.MediaTypeHeaderValue,HelloWorld.Domain.Host.Web.Areas.HelpPage.SampleDirection,System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Creates a new <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey" /> based on media type, <see cref="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.SampleDirection" />, controller name, action name and parameter names.
            </summary>
      <param name="mediaType">The media type.</param>
      <param name="sampleDirection">The <see cref="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.SampleDirection" />.</param>
      <param name="controllerName">Name of the controller.</param>
      <param name="actionName">Name of the action.</param>
      <param name="parameterNames">The parameter names.</param>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.ControllerName">
      <summary>
            Gets the name of the controller.
            </summary>
      <value>
            The name of the controller.
            </value>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.ActionName">
      <summary>
            Gets the name of the action.
            </summary>
      <value>
            The name of the action.
            </value>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.MediaType">
      <summary>
            Gets the media type.
            </summary>
      <value>
            The media type.
            </value>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.ParameterNames">
      <summary>
            Gets the parameter names.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.SampleDirection">
      <summary>
            Gets the <see cref="P:HelloWorld.Domain.Host.Web.Areas.HelpPage.HelpPageSampleKey.SampleDirection" />.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ImageSample">
      <summary>
            This represents an image sample on the help page. There's a display template named ImageSample associated with this class.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.ImageSample.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ImageSample" /> class.
            </summary>
      <param name="src">The URL of an image.</param>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.InvalidSample">
      <summary>
            This represents an invalid sample on the help page. There's a display template named InvalidSample associated with this class.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.ObjectGenerator">
      <summary>
            This class will create an object of a given type and populate it with sample data.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.ObjectGenerator.GenerateObject(System.Type)">
      <summary>
            Generates an object for a given type. The type needs to be public, have a public default constructor and settable public properties/fields. Currently it supports the following types:
            Simple types: <see cref="T:System.Int32" />, <see cref="T:System.String" />, <see cref="T:System.Enum" />, <see cref="T:System.DateTime" />, <see cref="T:System.Uri" />, etc.
            Complex types: POCO types.
            Nullables: <see cref="T:System.Nullable`1" />.
            Arrays: arrays of simple types or complex types.
            Key value pairs: <see cref="T:System.Collections.Generic.KeyValuePair`2" />
            Tuples: <see cref="T:System.Tuple`1" />, <see cref="T:System.Tuple`2" />, etc
            Dictionaries: <see cref="T:System.Collections.Generic.IDictionary`2" /> or anything deriving from <see cref="T:System.Collections.Generic.IDictionary`2" />.
            Collections: <see cref="T:System.Collections.Generic.IList`1" />, <see cref="T:System.Collections.Generic.IEnumerable`1" />, <see cref="T:System.Collections.Generic.ICollection`1" />, <see cref="T:System.Collections.IList" />, <see cref="T:System.Collections.IEnumerable" />, <see cref="T:System.Collections.ICollection" /> or anything deriving from <see cref="T:System.Collections.Generic.ICollection`1" /> or <see cref="T:System.Collections.IList" />.
            Queryables: <see cref="T:System.Linq.IQueryable" />, <see cref="T:System.Linq.IQueryable`1" />.
            </summary>
      <param name="type">The type.</param>
      <returns>An object of the given type.</returns>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.SampleDirection">
      <summary>
            Indicates whether the sample is used for request or response
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.TextSample">
      <summary>
            This represents a preformatted text sample on the help page. There's a display template named TextSample associated with this class.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.XmlDocumentationProvider">
      <summary>
            A custom <see cref="T:System.Web.Http.Description.IDocumentationProvider" /> that reads the API documentation from an XML documentation file.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Areas.HelpPage.XmlDocumentationProvider.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:HelloWorld.Domain.Host.Web.Areas.HelpPage.XmlDocumentationProvider" /> class.
            </summary>
      <param name="documentPath">The physical path to XML document.</param>
    </member>
    <member name="T:HelloWorld.Domain.Host.Web.Configuration.WebHostModule">
      <summary>
            The <see cref="T:Ninject.Modules.INinjectModule" /> for use with the domain package.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Configuration.WebHostModule.RegisterLogger">
      <summary>
            Register the <see cref="T:cdmdotnet.Logging.ILogger" /></summary>
    </member>
    <member name="M:HelloWorld.Domain.Host.Web.Configuration.WebHostModule.RegisterWebApi">
      <summary>
            Register the some WebAPI and SignalR requirements
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Akka.Controllers.HelloWorldExampleController">
      <summary>
            An <see cref="T:Cqrs.WebApi.CqrsEventApiController`1">API controller</see> for all publically exposed <see cref="T:HelloWorld.Domain.Akka.HelloWorldExample">HelloWorldExample</see> methods and queries.
            <see cref="T:HelloWorld.Domain.Akka.HelloWorldExample">HelloWorldExample</see> is described as:
            
            </summary>
      <remarks>
            Ensure you include the nuget package Cqrs.WebApi.
            For automatic help documentation generation visit 
            https://www.asp.net/web-api/overview/getting-started-with-aspnet-web-api/creating-api-help-pages
            and start at the section "Adding Help Pages to an Existing Project".
            Then enable XML documentation for all projects for both DEBUG and RELEASE builds.
            </remarks>
      <remarks>
            Ensure you include the nuget package Cqrs.WebApi.
            For automatic help documentation generation visit 
            https://www.asp.net/web-api/overview/getting-started-with-aspnet-web-api/creating-api-help-pages
            and start at the section "Adding Help Pages to an Existing Project".
            Then enable XML documentation for all projects for both DEBUG and RELEASE builds.
            </remarks>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Controllers.HelloWorldExampleController.#ctor(cdmdotnet.Logging.ILogger,cdmdotnet.Logging.ICorrelationIdHelper,Cqrs.Authentication.IAuthenticationTokenHelper{Cqrs.Authentication.SingleSignOnToken},Cqrs.Events.IEventStore{Cqrs.Authentication.SingleSignOnToken},Cqrs.Commands.ICommandPublisher{Cqrs.Authentication.SingleSignOnToken},Cqrs.Services.IUnitOfWorkService,Cqrs.Repositories.Queries.IQueryFactory)">
      <summary>
            Instantiate a new instance of the <see cref="T:HelloWorld.Domain.Akka.Controllers.HelloWorldExampleController" /> class
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Controllers.HelloWorldExampleController.GetEventData(System.Guid)">
      <summary>
            Query for all the events that match the provided CorrelationId.
            </summary>
      <param name="correlationId">The CorrelationId of the matching events.</param>
      <returns>A <see cref="T:Cqrs.Services.IServiceResponseWithResultData`1">service-response</see> with a collection of <see cref="T:Cqrs.Events.EventData">event data</see></returns>
    </member>
  </members>
  <assembly>
    <name>Cqrs</name>
  </assembly>
  <members>
    <member name="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn">
      <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn" /> and <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn" /></summary>
    </member>
    <member name="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsnAndCompanyRsn">
      <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn" /> and <see cref="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn" /></summary>
    </member>
    <member name="T:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn">
      <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken" /> that includes an identifiable <see cref="P:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn.CompanyRsn" /> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
    </member>
    <member name="P:Cqrs.Authentication.ISingleSignOnTokenWithCompanyRsn.CompanyRsn">
      <summary>
            The Rsn of the company the user doing the operation is operating on.
            When used in a system where a single user can have access to multiple companies, this is not the company the user belongs to, but the company it is operating on.
            When used by an external 3rd party this is the all in context of the person being impersonated, not the 3rd party system itself.
            </summary>
    </member>
    <member name="T:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn">
      <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken" /> that includes an identifiable <see cref="P:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn.UserRsn" /> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
    </member>
    <member name="P:Cqrs.Authentication.ISingleSignOnTokenWithUserRsn.UserRsn">
      <summary>
            The Rsn of the user doing the operation. When used by an external 3rd party this is the person being impersonated, not the 3rd party system itself.
            </summary>
    </member>
    <member name="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.CompanyRsn">
      <summary>
            The Rsn of the company the user doing the operation is operating on.
            When used in a system where a single user can have access to multiple companies, this is not the company the user belongs to, but the company it is operating on.
            When used by an external 3rd party this is the all in context of the person being impersonated, not the 3rd party system itself.
            </summary>
    </member>
    <member name="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsnAndCompanyRsn.UserRsn">
      <summary>
            The Rsn of the user doing the operation. When used by an external 3rd party this is the person being impersonated, not the 3rd party system itself.
            </summary>
    </member>
    <member name="T:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn">
      <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken" /> that includes an identifiable <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn" /> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
    </member>
    <member name="P:Cqrs.Authentication.SingleSignOnTokenWithCompanyRsn.CompanyRsn">
      <summary>
            The Rsn of the company the user doing the operation is operating on.
            When used in a system where a single user can have access to multiple companies, this is not the company the user belongs to, but the company it is operating on.
            When used by an external 3rd party this is the all in context of the person being impersonated, not the 3rd party system itself.
            </summary>
    </member>
    <member name="T:Cqrs.Authentication.SingleSignOnTokenWithUserRsn">
      <summary>
            This is a <see cref="T:Cqrs.Authentication.ISingleSignOnToken" /> that includes an identifiable <see cref="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn" /> to optimise the hits of the <see cref="T:Cqrs.DataStores.IDataStore`1">DataStores</see> by including data you most likely need.
            As such, if not used correctly, this can expose identifiable information.
            It is suggested the service layer populates this before sending commands as part of authorisation/authentication.
            </summary>
    </member>
    <member name="P:Cqrs.Authentication.SingleSignOnTokenWithUserRsn.UserRsn">
      <summary>
            The Rsn of the user doing the operation. When used by an external 3rd party this is the person being impersonated, not the 3rd party system itself.
            </summary>
    </member>
    <member name="M:Cqrs.Bus.IBusHelper.IsEventRequired(System.Type)">
      <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager" /> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
      <param name="messageType">The <see cref="T:System.Type" /> of the message being processed.</param>
    </member>
    <member name="M:Cqrs.Bus.IBusHelper.IsEventRequired(System.String)">
      <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager" /> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
      <param name="configurationKey">The configuration key to check.</param>
    </member>
    <member name="M:Cqrs.Bus.IBusHelper.BuildTelemeteredActionHandler``2(cdmdotnet.Logging.ITelemetryHelper,System.Action{``0},System.Boolean,System.String)">
      <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
    </member>
    <member name="M:Cqrs.Bus.BusHelper.IsEventRequired(System.Type)">
      <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager" /> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
      <param name="messageType">The <see cref="T:System.Type" /> of the message being processed.</param>
    </member>
    <member name="M:Cqrs.Bus.BusHelper.IsEventRequired(System.String)">
      <summary>
            Checks if a white-list or black-list approach is taken, then checks the <see cref="T:Cqrs.Configuration.IConfigurationManager" /> to see if a key exists defining if the event is required or not.
            If the event is required and it cannot be resolved, an error will be raised.
            Otherwise the event will be marked as processed.
            </summary>
      <param name="configurationKey">The configuration key to check.</param>
    </member>
    <member name="M:Cqrs.Bus.BusHelper.BuildTelemeteredActionHandler``2(cdmdotnet.Logging.ITelemetryHelper,System.Action{``0},System.Boolean,System.String)">
      <summary>
            Build a message handler that implements telemetry capturing as well as off thread handling.
            </summary>
    </member>
    <member name="T:Cqrs.Bus.ICommandHandlerRegistrar">
      <summary>
            Registers command handlers that listen and respond to commands.
            </summary>
    </member>
    <member name="T:Cqrs.Bus.IHandlerRegistrar">
      <summary>
            Registers event or command handlers that listen and respond to events or commands.
            </summary>
    </member>
    <member name="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)">
      <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
      <remarks>
            In many cases the <paramref name="targetedType" /> will be the event handler class itself, what you actually want is the target of what is being updated
            </remarks>
    </member>
    <member name="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Boolean)">
      <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
    </member>
    <member name="T:Cqrs.Bus.IEventHandlerRegistrar">
      <summary>
            Registers event handlers that listen and respond to events.
            </summary>
    </member>
    <member name="M:Cqrs.Bus.RouteManager.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)">
      <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
    </member>
    <member name="M:Cqrs.Bus.RouteManager.RegisterHandler``1(System.Action{``0},System.Boolean)">
      <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
    </member>
    <member name="T:Cqrs.Commands.DtoCommand`2">
      <summary>
            A <see cref="T:Cqrs.Commands.ICommand`1" /> for <see cref="T:Cqrs.Domain.IDto" /> objects
            </summary>
    </member>
    <member name="T:Cqrs.Commands.ICommand`1">
      <summary>
            People request changes to the domain by sending <see cref="T:Cqrs.Commands.ICommand`1" />s. They are named with a verb in the imperative mood plus and may include the <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> type, for example ConfirmOrder. Unlike an <see cref="T:Cqrs.Events.IEvent`1" />, a <see cref="T:Cqrs.Commands.ICommand`1" /> is not a statement of fact; it's only a request, and thus may be refused. (A typical way to convey refusal is to raise a specifically typed <see cref="T:Cqrs.Events.IEvent`1" /> stating the <see cref="T:Cqrs.Commands.ICommand`1" /> didn't happen for a specific reason).
            </summary>
      <example>
            public class ConfirmOrder
            {
            	public Guid OrderRsn;
            }
            </example>
      <remarks>
            What does a <see cref="T:Cqrs.Commands.ICommand`1" /> or an <see cref="T:Cqrs.Events.IEvent`1" /> look like?
            
            An <see cref="T:Cqrs.Commands.ICommand`1" /> or <see cref="T:Cqrs.Events.IEvent`1" /> is simply a data structure that contain data for reading, and no behavior. We call such structures "Data Transfer Objects" (DTOs). The name indicates the purpose. In many languages they are represented as classes, but they are not true classes in the real OO sense.
            
            
            What is the difference between a <see cref="T:Cqrs.Commands.ICommand`1" /> and an <see cref="T:Cqrs.Events.IEvent`1" />?
            
            Their intent.
            
            
            What is immutability? Why is a <see cref="T:Cqrs.Commands.ICommand`1" /> or <see cref="T:Cqrs.Events.IEvent`1" /> immutable?
            
            For the purpose of this question, immutability is not having any setters, or other methods which change internal state. The <see cref="T:System.String" /> type in is a familiar example; you never actually change an existing <see cref="T:System.String" /> value, you just create new <see cref="T:System.String" /> values based on old ones.
            
            An <see cref="T:Cqrs.Commands.ICommand`1" /> is immutable because their expected usage is to be sent directly to the domain model side for processing. They do not need to change during their projected lifetime in traveling from client to server.
            Sometimes however business logic dictates that a decision may be made to construct a <see cref="T:Cqrs.Commands.ICommand`1" /> and local variables should be used.
            
            An <see cref="T:Cqrs.Events.IEvent`1" /> is immutable because they represent domain actions that took place in the past. Unless you're Marty McFly, you can't change the past, and sometimes not even then.
            
            
            What is command upgrading?
            
            Upgrading an <see cref="T:Cqrs.Commands.ICommand`1" /> becomes necessary when new requirements cause an existing <see cref="T:Cqrs.Commands.ICommand`1" /> not to be sufficient. Maybe a new field needs to be added, for example, or maybe an existing field should really have been split into several different ones.
            
            
            How do I upgrade my <see cref="T:Cqrs.Commands.ICommand`1" />s?
            
            How you do the upgrade depends how much control you have over your clients. If you can deploy your client updates and server updates together, just change things in both and deploy the updates. Job done. If not, it's usually best to have the updated <see cref="T:Cqrs.Commands.ICommand`1" /> be a new type and have the <see cref="T:Cqrs.Commands.ICommandHandler`2" /> accept both for a while.
            
            
            Could you give an example of names of some versioned <see cref="T:Cqrs.Commands.ICommand`1" />?
            
            Sure.
            
            UploadFile
            UploadFile_v2
            UploadFile_v3
            
            It's just a convention, but a sane one.
            ********************************************
            Also see http://cqrs.nu/Faq/commands-and-events.
            </remarks>
    </member>
    <member name="P:Cqrs.Messages.IMessage.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:Cqrs.Messages.IMessage.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="P:Cqrs.Commands.DtoCommand`2.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:Cqrs.Commands.DtoCommand`2.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="T:Cqrs.Commands.ICommandHandler`2">
      <summary>
            An <see cref="T:Cqrs.Commands.ICommandHandler`2" /> receives an <see cref="T:Cqrs.Commands.ICommand`1" /> and brokers a result from the appropriate <see cref="T:Cqrs.Domain.IAggregateRoot`1" />.
            "A result" is either a successful application of the command, or an exception.
            This is the common sequence of steps an <see cref="T:Cqrs.Commands.ICommandHandler`2" /> might follow:
            
            Validate the <see cref="T:Cqrs.Commands.ICommand`1" /> on its own merits.
            Ask an <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> to handle the <see cref="T:Cqrs.Commands.ICommand`1" />.
            If validation is successful, 0..n <see cref="T:Cqrs.Events.IEvent`1" /> artefacts (1 is common) are queued for publishing.
            Attempt to persist the new <see cref="T:Cqrs.Events.IEvent`1" /> artefacts. If there's a concurrency conflict during this step, either give up, or retry things.
            Dispatch the queued <see cref="T:Cqrs.Events.IEvent`1" /> artefacts.
            </summary>
      <remarks>
            Should a <see cref="T:Cqrs.Commands.ICommandHandler`2" /> affect one or several <see cref="T:Cqrs.Domain.IAggregateRoot`1" />s?
            
            Only one.
            
            
            Do I put logic in <see cref="T:Cqrs.Commands.ICommandHandler`2" />?
            
            Yes. Exactly what logic depends on your factoring.
            The logic for validating the <see cref="T:Cqrs.Commands.ICommand`1" /> on its own merits always gets executed in the <see cref="T:Cqrs.Commands.ICommandHandler`2" />, although we recommend refactoring these into an <see cref="T:Cqrs.Commands.ICommandValidator`2" />.
            Provided validation is successful we recommend a more functional factoring, where the <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> exists independently of the <see cref="T:Cqrs.Commands.ICommandHandler`2" /> and the next step would be to load the <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> from the <see cref="T:Cqrs.Domain.IUnitOfWork`1" /> and request the <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> handle the <see cref="T:Cqrs.Commands.ICommand`1" /> itself.
            The <see cref="T:Cqrs.Domain.IUnitOfWork`1" /> should then have uncommitted <see cref="T:Cqrs.Events.IEvent`1" /> artefacts as a results of asking the <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> to handle the <see cref="T:Cqrs.Commands.ICommand`1" />.
            Finally the <see cref="T:Cqrs.Commands.ICommandHandler`2" /> should instruct the <see cref="T:Cqrs.Domain.IUnitOfWork`1" /> to <see cref="M:Cqrs.Domain.IUnitOfWork`1.Commit" /> all uncommited <see cref="T:Cqrs.Events.IEvent`1" /> artefacts.
            
            However you have it, the logic boils down to validation and some sequence of steps that lead to the <see cref="T:Cqrs.Commands.ICommand`1" /> becoming an <see cref="T:System.Exception" /> or <see cref="T:Cqrs.Events.IEvent`1" />(s). If you're tempted to go beyond this, see the rest of the remarks.
            
            
            Can I call a read side (such as a read store, data store or <see cref="T:Cqrs.Domain.IRepository`1" />) from my <see cref="T:Cqrs.Commands.ICommandHandler`2" />?
            
            No.
            
            
            Can I do logging, security, or auditing in my <see cref="T:Cqrs.Commands.ICommandHandler`2" />?
            
            Yes. The decorator pattern comes in handy here to separate those concerns neatly.
            
            
            How are conflicts between concurrent <see cref="T:Cqrs.Commands.ICommand`1" />s handled in the <see cref="T:Cqrs.Commands.ICommandHandler`2" />?
            
            The place where the new <see cref="T:Cqrs.Events.IEvent`1" /> artefacts for the <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> are persisted is the only place in the system where we need to worry about concurrency conflicts. The <see cref="T:Cqrs.Events.IEventStore`1" /> knows the sequence number of the latest <see cref="T:Cqrs.Events.IEvent`1" /> applied on that <see cref="T:Cqrs.Domain.IAggregateRoot`1" />, and the <see cref="T:Cqrs.Commands.ICommandHandler`2" /> knows the sequence number of the last <see cref="T:Cqrs.Events.IEvent`1" /> it read. If these numbers do not agree, it means some other thread or process got there first. The <see cref="T:Cqrs.Commands.ICommandHandler`2" /> can then load up the events again and make a new attempt.
            
            
            Should I do things that have side-effects in the outside world (such as sending email) directly in a <see cref="T:Cqrs.Commands.ICommandHandler`2" />?
            
            No, since a concurrency conflict will mean the <see cref="T:Cqrs.Commands.ICommandHandler`2" /> logic will be run again. Do such things in an Apply <see cref="T:Cqrs.Events.IEvent`1" /> method in an <see cref="T:Cqrs.Domain.IAggregateRoot`1" />.
            ********************************************
            Also see http://cqrs.nu/Faq/command-handlers.
            </remarks>
    </member>
    <member name="T:Cqrs.Commands.ICommandPublisher`1">
      <summary>
            Publishes an <see cref="T:Cqrs.Commands.ICommand`1" /></summary>
    </member>
    <member name="T:Cqrs.Commands.ISendAndWaitCommandSender`1">
      <summary>
            Sends an <see cref="T:Cqrs.Commands.ICommand`1" /></summary>
      <typeparam name="TAuthenticationToken" />
    </member>
    <member name="T:Cqrs.Commands.ICommandSender`1">
      <summary>
            Sends an <see cref="T:Cqrs.Commands.ICommand`1" /></summary>
      <typeparam name="TAuthenticationToken" />
    </member>
    <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /></summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /> or exits if the specified timeout is expired.
            </summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /> or exits if the specified timeout is expired.
            </summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent" /></summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent" /> that is desired, return null to keep trying.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /> or exits if the specified timeout is expired.
            </summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent" /> that is desired, return null to keep trying.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Commands.ISendAndWaitCommandSender`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /> or exits if the specified timeout is expired.
            </summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent" /> that is desired, return null to keep trying.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="T:Cqrs.Commands.ICommandValidator`2">
      <summary>
            Validates an <see cref="T:Cqrs.Commands.ICommand`1" /> on its own merits.
            </summary>
    </member>
    <member name="M:Cqrs.Commands.ICommandValidator`2.IsCommandValid(`1)">
      <summary>
            Validates the provided <param name="command" /> on its own merits.
            </summary>
    </member>
    <member name="T:Cqrs.DataStores.IDataStore`1">
      <summary>
            A data store capable of being queried and modified
            </summary>
    </member>
    <member name="M:Cqrs.DataStores.IDataStore`1.Remove(`0)">
      <summary>
            Will mark the <paramref name="data" /> as logically (or soft).
            </summary>
    </member>
    <member name="M:Cqrs.DataStores.InProcessDataStore`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Cqrs.DataStores.InProcessDataStore`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Cqrs.DataStores.InProcessDataStore`1.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:Cqrs.DataStores.InProcessDataStore`1.Remove(`0)">
      <summary>
            Will mark the <paramref name="data" /> as logically (or soft) by setting <see cref="P:Cqrs.Entities.Entity.IsLogicallyDeleted" /> to true
            </summary>
    </member>
    <member name="P:Cqrs.DataStores.InProcessDataStore`1.Expression">
      <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable" />.
            </summary>
      <returns>
            The <see cref="T:System.Linq.Expressions.Expression" /> that is associated with this instance of <see cref="T:System.Linq.IQueryable" />.
            </returns>
    </member>
    <member name="P:Cqrs.DataStores.InProcessDataStore`1.ElementType">
      <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable" /> is executed.
            </summary>
      <returns>
            A <see cref="T:System.Type" /> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.
            </returns>
    </member>
    <member name="P:Cqrs.DataStores.InProcessDataStore`1.Provider">
      <summary>
            Gets the singleResultQuery provider that is associated with this data source.
            </summary>
      <returns>
            The <see cref="T:System.Linq.IQueryProvider" /> that is associated with this data source.
            </returns>
    </member>
    <member name="M:Cqrs.DataStores.SqlDataStore`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Cqrs.DataStores.SqlDataStore`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Cqrs.DataStores.SqlDataStore`1.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
    </member>
    <member name="M:Cqrs.DataStores.SqlDataStore`1.Remove(`0)">
      <summary>
            Will mark the <paramref name="data" /> as logically (or soft) by setting <see cref="P:Cqrs.Entities.Entity.IsLogicallyDeleted" /> to true
            </summary>
    </member>
    <member name="P:Cqrs.DataStores.SqlDataStore`1.Expression">
      <summary>
            Gets the expression tree that is associated with the instance of <see cref="T:System.Linq.IQueryable" />.
            </summary>
      <returns>
            The <see cref="T:System.Linq.Expressions.Expression" /> that is associated with this instance of <see cref="T:System.Linq.IQueryable" />.
            </returns>
    </member>
    <member name="P:Cqrs.DataStores.SqlDataStore`1.ElementType">
      <summary>
            Gets the type of the element(s) that are returned when the expression tree associated with this instance of <see cref="T:System.Linq.IQueryable" /> is executed.
            </summary>
      <returns>
            A <see cref="T:System.Type" /> that represents the type of the element(s) that are returned when the expression tree associated with this object is executed.
            </returns>
    </member>
    <member name="P:Cqrs.DataStores.SqlDataStore`1.Provider">
      <summary>
            Gets the query provider that is associated with this data source.
            </summary>
      <returns>
            The <see cref="T:System.Linq.IQueryProvider" /> that is associated with this data source.
            </returns>
    </member>
    <member name="T:Cqrs.Domain.IAggregateRoot`1">
      <summary>
            An <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> is a larger unit of encapsulation than just a class. Every transaction is scoped to a single aggregate. The lifetimes of the components of an <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> are bounded by the lifetime of the entire <see cref="T:Cqrs.Domain.IAggregateRoot`1" />.
            
            <para />Concretely, an <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> will handle <see cref="T:Cqrs.Commands.ICommand`1" />s, apply <see cref="T:Cqrs.Events.IEvent`1" />s, and have a state model encapsulated within it that allows it to implement the required command validation, thus upholding the invariants (business rules) of the <see cref="T:Cqrs.Domain.IAggregateRoot`1" />.
            </summary>
      <remarks>
            I know <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> are transaction boundaries, but I really need to transactionally update two <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> in the same transaction. What should I do?
            
            <para />You should re-think the following:
            <para />* Your <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> boundaries.
            <para />* The responsibilities of each <see cref="T:Cqrs.Domain.IAggregateRoot`1" />.
            <para />* What you can get away with doing in a read side or in a saga.
            <para />* The actual non-functional requirements of your domain.
            <para /><para />If you write a solution where two or more <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> are transactionally coupled, you have not understood <see cref="T:Cqrs.Domain.IAggregateRoot`1" />.
            <para /><para /><para />Why is the use of <see cref="T:System.Guid" /> as identifiers a good practice?
            <para /><para />Because they are (reasonably) globally unique, and can be generated either by the server or by the client.
            <para /><para /><para />What is an Rsn and what is an Id?
            <para /><para />Because few systems are truely green field and there is usually some existing system to operate with our framework identifies
            <para />Id properties as <see cref="T:System.Int32" /> typed properties from an external system
            <para />and Rsn properties as <see cref="T:System.Guid" /> typed properties for internal use.
            <para /><para />An example might be
            <para />{
            <para />	Guid Rsn
            <para />	string Name
            <para />	Guid CategoryRsn
            <para />	int CategoryId
            <para />}
            <para /><para />Here the category can be referenced within the CQRS framework by it's Rsn <see cref="T:System.Guid" /> typed identifier, but still has a reference to the external systems <see cref="T:System.Int32" /> typed identifier value.
            <para /><para /><para />How can I get the Rsn for newly created <see cref="T:Cqrs.Domain.IAggregateRoot`1" />?
            <para /><para />It's an important insight that the client can generate its own Rsns.
            <para /><para />If the client generates a <see cref="T:System.Guid" /> and places it in the create-the-aggregate <see cref="T:Cqrs.Commands.ICommand`1" />, this is a non-issue. Otherwise, you have to listen to the the appropriate the-aggregate-was-created <see cref="T:Cqrs.Events.IEvent`1" />, where the Rsn will appear be populated.
            <para /><para /><para />Should I allow references between <see cref="T:Cqrs.Domain.IAggregateRoot`1" />?
            <para /><para />In the sense of an actual "memory reference", absolutely not.
            <para /><para />On the write side, an actual memory reference from one <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> to another is forbidden and wrong, since <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> by definition are not allowed to reach outside of themselves. (Allowing this would mean an <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> is no longer a transaction boundary, meaning we can no longer sanely reason about its ability to uphold its invariants; it would also preclude sharding of <see cref="T:Cqrs.Domain.IAggregateRoot`1" />.)
            <para /><para />Referring to another <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> using an identifier is fine. It is useless on the write side (since the identifier must be treated as an opaque value, since <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> can not reach outside of themselves). Read sides may freely use such information, however, to do interesting correlations.
            <para /><para /><para />How can I validate a <see cref="T:Cqrs.Commands.ICommand`1" /> across a group of <see cref="T:Cqrs.Domain.IAggregateRoot`1" />?
            <para /><para />This is a common reaction to not being able to query across <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> anymore. There are several answers:
            <para /><para />* Do client-side validation.
            <para />* Use a read side.
            <para />* Use a saga.
            <para />* If those are all completely impractical, then it's time to consider if you got your <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> boundaries correct.
            <para /><para /><para />How can I guarantee referential integrity across <see cref="T:Cqrs.Domain.IAggregateRoot`1" />?
            <para /><para />You're still thinking in terms of foreign relations, not <see cref="T:Cqrs.Domain.IAggregateRoot`1" />. See last question. Also, remember that just because something would be in two tables in a relational design does not in any way suggest it should be two <see cref="T:Cqrs.Domain.IAggregateRoot`1" />. Designing an <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> is different.
            <para /><para /><para />How can I make sure a newly created user has a unique user name?
            <para /><para />This is a commonly occurring question since we're explicitly not performing cross-aggregate operations on the write side. We do, however, have a number of options:
            <para /><para />* Create a read-side of already allocated user names. Make the client query the read-side interactively as the user types in a name.
            <para />* Create a reactive saga to flag down and inactivate accounts that were nevertheless created with a duplicate user name. (Whether by extreme coincidence or maliciously or because of a faulty client.)
            <para /><para /><para />How can I verify that a customer identifier really exists when I place an order?
            <para /><para />Assuming customer and order are <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> here, it's clear that the order <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> cannot really validate this, since that would mean reaching out of the <see cref="T:Cqrs.Domain.IAggregateRoot`1" />.
            <para /><para />Checking up on it after the fact, in a saga or just in a read side that records "broken" orders, is one option. After all, the most important thing about an order is actually recording it, and presumably any interesting data about the recipient of the order is being copied into the order <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> (referring to the customer to find the address is bad design; the order was always made to be deliverd to a particular address, whether or not that customer changes their address in the future).
            <para /><para />Being able to use what data was recorded in this broken order means you've got a chance to rescue it and rectify the situation - which makes a good bit more business sense rather than dropping the order on the floor because a foreign key constraint was violated!
            <para /><para /><para />How can I update a set of <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> with a single <see cref="T:Cqrs.Commands.ICommand`1" />?
            <para /><para />A single <see cref="T:Cqrs.Commands.ICommand`1" /> can't act on a set of <see cref="T:Cqrs.Domain.IAggregateRoot`1" />. It just can't.
            <para /><para />First off, ask yourself whether you really need to update several <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> using just one <see cref="T:Cqrs.Commands.ICommand`1" />. What in the situation makes this a requirement?
            <para /><para />However, here's what you could do. Allow a new kind of "bulk command", conceptually containing the command you want to issue, and a set of <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> (specified either explicitly or implicitly) that you want to issue it on. The write side isn't powerful enough to make the bulk action, but it's able to create a corresponding "bulk event". A saga captures the event, and issues the <see cref="T:Cqrs.Commands.ICommand`1" /> on each of the specified <see cref="T:Cqrs.Domain.IAggregateRoot`1" />s. The saga can do rollback or send an email, as appropriate, if some of the <see cref="T:Cqrs.Commands.ICommand`1" /> fail.
            <para /><para />There are some advantages to this approach: we store the intent of the bulk action in the event store. The saga automates rollback or equivalent.
            <para /><para />Still, having to resort to this solution is a strong indication that your <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> boundaries are not drawn correctly. You might want to consider changing your <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> boundaries rather than building a saga for this.
            <para /><para /><para />What is sharding?
            <para /><para />A way to distribute large amounts of <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> on several write-side nodes. We can shard <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> easily because they are completely self-reliant.
            <para /><para />We can shard <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> easily because they don't have any external references.
            <para /><para /><para />Can an <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> send an <see cref="T:Cqrs.Events.IEvent`1" /> to another <see cref="T:Cqrs.Domain.IAggregateRoot`1" />?
            <para /><para />No.
            <para /><para />The factoring of your <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> and <see cref="T:Cqrs.Commands.ICommandHandler`2" /> will typically already make this idea impossible to express in code. But there's a deeper philosophical reason: go back and re-read the first sentence in the answer to "What is an <see cref="T:Cqrs.Domain.IAggregateRoot`1" />?". If you manage to circumvent the <see cref="T:Cqrs.Commands.ICommandHandler`2" /> and just push <see cref="T:Cqrs.Events.IEvent`1" /> into another <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> somehow, you will have taken away that <see cref="T:Cqrs.Domain.IAggregateRoot`1" />'s chance to participate in validation of changes. That's ultimately why we only allow <see cref="T:Cqrs.Events.IEvent`1" /> to be created as a result of <see cref="T:Cqrs.Commands.ICommand`1" />s validated by a <see cref="T:Cqrs.Commands.ICommandHandler`2" /> on an <see cref="T:Cqrs.Domain.IAggregateRoot`1" />.
            <para /><para /><para />Can I call a read side from my <see cref="T:Cqrs.Domain.IAggregateRoot`1" />?
            <para /><para />No.
            <para /><para /><para />How do I send e-mail in a CQRS system?
            <para /><para />In an <see cref="T:Cqrs.Events.IEventHandler`2" /> outside of the <see cref="T:Cqrs.Domain.IAggregateRoot`1" />. Do not do it in the <see cref="T:Cqrs.Commands.ICommandHandler`2" />, as if the <see cref="T:Cqrs.Events.IEvent`1" /> artefacts are not persisted due to losing a race with another <see cref="T:Cqrs.Commands.ICommand`1" /> then the email will have been sent on a false premise.
            <para />********************************************
            <para />Also see http://cqrs.nu/Faq/aggregates.
            </remarks>
    </member>
    <member name="T:Cqrs.Domain.IUnitOfWork`1">
      <summary>
            This is a Unit of Work
            </summary>
    </member>
    <member name="M:Cqrs.Domain.IUnitOfWork`1.Add``1(``0)">
      <summary>
            Add an item into the <see cref="T:Cqrs.Domain.IUnitOfWork`1" /> ready to be committed.
            </summary>
    </member>
    <member name="M:Cqrs.Domain.IUnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32})">
      <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1" /> if it has already been loaded.
            </summary>
    </member>
    <member name="M:Cqrs.Domain.IUnitOfWork`1.Commit">
      <summary>
            Commit any changed <see cref="T:Cqrs.Domain.AggregateRoot`1" /> added to this <see cref="T:Cqrs.Domain.IUnitOfWork`1" /> via <see cref="M:Cqrs.Domain.IUnitOfWork`1.Add``1(``0)" /></summary>
    </member>
    <member name="T:Cqrs.Domain.UnitOfWork`1">
      <summary>
            This is a Unit of Work. This shouldn't normally be used as a singleton.
            </summary>
    </member>
    <member name="M:Cqrs.Domain.UnitOfWork`1.Add``1(``0)">
      <summary>
            Add an item into the <see cref="T:Cqrs.Domain.IUnitOfWork`1" /> ready to be committed.
            </summary>
    </member>
    <member name="M:Cqrs.Domain.UnitOfWork`1.Get``1(System.Guid,System.Nullable{System.Int32})">
      <summary>
            Get an item from the <see cref="T:Cqrs.Domain.IUnitOfWork`1" /> if it has already been loaded or get it from the <see cref="T:Cqrs.Domain.IRepository`1" />.
            </summary>
    </member>
    <member name="M:Cqrs.Domain.UnitOfWork`1.Commit">
      <summary>
            Commit any changed <see cref="T:Cqrs.Domain.AggregateRoot`1" /> added to this <see cref="T:Cqrs.Domain.IUnitOfWork`1" /> via <see cref="M:Cqrs.Domain.UnitOfWork`1.Add``1(``0)" />
            into the <see cref="T:Cqrs.Domain.IRepository`1" /></summary>
    </member>
    <member name="T:Cqrs.Entities.DecimalRange">
      <summary>
            A <see cref="T:Cqrs.Entities.Range`1" /> object for collecting a <see cref="T:System.Decimal" /> lower and upper limit.
            </summary>
    </member>
    <member name="T:Cqrs.Entities.Range`1">
      <summary>
            A range object for collecting a lower and upper limit, such as a number or date range.
            </summary>
    </member>
    <member name="P:Cqrs.Entities.Range`1.From">
      <summary>
            The lower limit such as a from <see cref="T:System.DateTime" />.
            </summary>
    </member>
    <member name="P:Cqrs.Entities.Range`1.To">
      <summary>
            The upper limit such as a to <see cref="T:System.DateTime" />.
            </summary>
    </member>
    <member name="P:Cqrs.Entities.Range`1.IsFromInclusive">
      <summary>
            Is the value of <see cref="P:Cqrs.Entities.Range`1.From" /> inclusive or not. Defaults to true.
            </summary>
    </member>
    <member name="P:Cqrs.Entities.Range`1.IsToInclusive">
      <summary>
            Is the value of <see cref="P:Cqrs.Entities.Range`1.To" /> inclusive or not. Defaults to true.
            </summary>
    </member>
    <member name="M:Cqrs.Entities.DecimalRange.#ctor">
      <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Entities.DecimalRange" /> class.
            </summary>
    </member>
    <member name="T:Cqrs.Entities.IntegerRange">
      <summary>
            A <see cref="T:Cqrs.Entities.Range`1" /> object for collecting a <see cref="T:System.Int32" /> lower and upper limit.
            </summary>
    </member>
    <member name="M:Cqrs.Entities.IntegerRange.#ctor">
      <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Entities.IntegerRange" /> class.
            </summary>
    </member>
    <member name="T:Cqrs.Entities.DateRange">
      <summary>
            A <see cref="T:Cqrs.Entities.Range`1" /> object for collecting a <see cref="T:System.DateTime" /> lower and upper limit.
            </summary>
    </member>
    <member name="M:Cqrs.Entities.DateRange.#ctor">
      <summary>
            Instantiates and Initialises a new instance of the <see cref="T:Cqrs.Entities.DateRange" /> class.
            </summary>
    </member>
    <member name="T:Cqrs.Events.NotifyEveryoneExceptCallerEventAttribute">
      <summary>
            An <see cref="T:Cqrs.Events.IEvent`1" /> that should be sent to all connected people except the person who was authenticated when sending the request via SignalR.
            </summary>
    </member>
    <member name="T:Cqrs.Events.NotifyEveryoneEventAttribute">
      <summary>
            An <see cref="T:Cqrs.Events.IEvent`1" /> that should be sent to all connected people via SignalR.
            </summary>
    </member>
    <member name="T:Cqrs.Events.NotifyCallerEventAttribute">
      <summary>
            An <see cref="T:Cqrs.Events.IEvent`1" /> that should be sent back to the person who was authenticated when sending the request via SignalR.
            </summary>
    </member>
    <member name="T:Cqrs.Events.PrivateEventAttribute">
      <summary>
            An <see cref="T:Cqrs.Events.IEvent`1" /> that should be sent via the private <see cref="T:Cqrs.Events.IEventPublisher`1" />.
            </summary>
    </member>
    <member name="T:Cqrs.Events.EventStoreRetentionLevelAttribute">
      <summary>
            Provides a mechanism to configure different <see cref="T:Cqrs.Events.IEventStore`1" /> instances to save the event to.
            This is useful if you have events that should be in hot storage with quick loads and events that should be in cold storage and are unlikely to be reloaded and use slower cheaper storage.
            </summary>
    </member>
    <member name="P:Cqrs.Events.EventStoreRetentionLevelAttribute.RetentionLevel">
      <summary>
            The level of retention required. By specifying a value we look for a matching configured <see cref="T:Cqrs.Events.IEventStore`1" /> with the same level defined.
            </summary>
    </member>
    <member name="T:Cqrs.Events.MemoryCacheEventStore`1">
      <summary>
            A, <see cref="T:Cqrs.Events.EventStore`1" /> that uses a <see cref="T:System.Runtime.Caching.MemoryCache" /> implementation, flushing out data (I.E. it's not persisted)
            </summary>
    </member>
    <member name="M:Cqrs.Events.MemoryCacheEventStore`1.GetDetaultCacheItemPolicy">
      <summary>
            Get's a <see cref="T:System.Runtime.Caching.CacheItemPolicy" /> with the <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> set to 15 minutes
            </summary>
    </member>
    <member name="T:Cqrs.Events.IEvent`1">
      <summary>
            An <see cref="T:Cqrs.Events.IEvent`1" /> represents something that took place in the domain. They are always named with a past-participle verb, such as OrderConfirmed. It's not unusual, but not required, for an <see cref="T:Cqrs.Events.IEvent`1" /> to name an <see cref="T:Cqrs.Domain.IAggregateRoot`1" /> or <see cref="T:Cqrs.Entities.IEntity" /> that it relates to; let the domain language be your guide.
            
            Since an <see cref="T:Cqrs.Events.IEvent`1" /> represents something in the past, it can be considered a statement of fact and used to take decisions in other parts of the system.
            </summary>
      <example>
            public class OrderConfirmed 
            {
            	public Guid OrderRsn;
            	public DateTime ConfirmationDate;
            }
            </example>
      <remarks>
            What does a <see cref="T:Cqrs.Commands.ICommand`1" /> or an <see cref="T:Cqrs.Events.IEvent`1" /> look like?
            
            An <see cref="T:Cqrs.Commands.ICommand`1" /> or <see cref="T:Cqrs.Events.IEvent`1" /> is simply a data structure that contain data for reading, and no behavior. We call such structures "Data Transfer Objects" (DTOs). The name indicates the purpose. In many languages they are represented as classes, but they are not true classes in the real OO sense.
            
            
            What is the difference between a <see cref="T:Cqrs.Commands.ICommand`1" /> and an <see cref="T:Cqrs.Events.IEvent`1" />?
            
            Their intent.
            
            
            What is immutability? Why is a <see cref="T:Cqrs.Commands.ICommand`1" /> or <see cref="T:Cqrs.Events.IEvent`1" /> immutable?
            
            For the purpose of this question, immutability is not having any setters, or other methods which change internal state. The <see cref="T:System.String" /> type in is a familiar example; you never actually change an existing <see cref="T:System.String" /> value, you just create new <see cref="T:System.String" /> values based on old ones.
            
            An <see cref="T:Cqrs.Commands.ICommand`1" /> is immutable because their expected usage is to be sent directly to the domain model side for processing. They do not need to change during their projected lifetime in traveling from client to server.
            Sometimes however business logic dictates that a decision may be made to construct a <see cref="T:Cqrs.Commands.ICommand`1" /> and local variables should be used.
            
            An <see cref="T:Cqrs.Events.IEvent`1" /> is immutable because they represent domain actions that took place in the past. Unless you're Marty McFly, you can't change the past, and sometimes not even then.
            
            
            What is command upgrading?
            
            Upgrading an <see cref="T:Cqrs.Commands.ICommand`1" /> becomes necessary when new requirements cause an existing <see cref="T:Cqrs.Commands.ICommand`1" /> not to be sufficient. Maybe a new field needs to be added, for example, or maybe an existing field should really have been split into several different ones.
            
            
            How do I upgrade my <see cref="T:Cqrs.Commands.ICommand`1" />s?
            
            How you do the upgrade depends how much control you have over your clients. If you can deploy your client updates and server updates together, just change things in both and deploy the updates. Job done. If not, it's usually best to have the updated <see cref="T:Cqrs.Commands.ICommand`1" /> be a new type and have the <see cref="T:Cqrs.Commands.ICommandHandler`2" /> accept both for a while.
            
            
            Could you give an example of names of some versioned <see cref="T:Cqrs.Commands.ICommand`1" />?
            
            Sure.
            
            UploadFile
            UploadFile_v2
            UploadFile_v3
            
            It's just a convention, but a sane one.
            ********************************************
            Also see http://cqrs.nu/Faq/commands-and-events.
            </remarks>
    </member>
    <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:Cqrs.Events.DuplicateCreateCommandEvent`1.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="T:Cqrs.Events.IEventPublisher`1">
      <summary>
            Publishes an <see cref="T:Cqrs.Events.IEvent`1" /></summary>
    </member>
    <member name="P:Cqrs.Events.DtoAggregateEvent`2.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:Cqrs.Events.DtoAggregateEvent`2.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="T:Cqrs.Events.PublicEventAttribute">
      <summary>
            An <see cref="T:Cqrs.Events.IEvent`1" /> that should be sent via the public <see cref="T:Cqrs.Events.IEventPublisher`1" />.
            </summary>
    </member>
    <member name="T:Cqrs.Events.SqlEventStore`1">
      <summary>
            A simplified SqlServer based <see cref="T:Cqrs.Events.EventStore`1" /> that uses LinqToSql and follows a rigid schema.
            </summary>
    </member>
    <member name="T:Cqrs.Infrastructure.SpinWait">
      <summary>
            Provides support for spin-based waiting.
            </summary>
    </member>
    <member name="F:Cqrs.Infrastructure.SpinWait.DefaultSleepInMilliseconds">
      <summary>
            A recommended sleep value of 50.
            </summary>
    </member>
    <member name="M:Cqrs.Infrastructure.SpinWait.SpinOnce(System.Int16)">
      <summary>
            Performs a single spin.
            </summary>
      <param name="sleepInMilliseconds">The amount of milliseconds the thread will sleep for.</param>
    </member>
    <member name="M:Cqrs.Infrastructure.SpinWait.Reset">
      <summary>
            Resets the spin counter.
            </summary>
    </member>
    <member name="M:Cqrs.Infrastructure.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int16)">
      <summary>
            Spins until the specified condition is satisfied.
            </summary>
      <param name="condition">A delegate to be executed over and over until it returns true.</param>
      <param name="sleepInMilliseconds">The amount of milliseconds the thread will sleep for.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="condition" /> argument is null.</exception>
    </member>
    <member name="M:Cqrs.Infrastructure.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan,System.Int16)">
      <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
      <returns>
            True if the condition is satisfied within the timeout; otherwise, false
            </returns>
      <param name="condition">A delegate to be executed over and over until it returns true.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
      <param name="sleepInMilliseconds">The amount of milliseconds the thread will sleep for.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="condition" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <see cref="F:System.Int32.MaxValue" />.</exception>
    </member>
    <member name="M:Cqrs.Infrastructure.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32,System.Int16)">
      <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
      <returns>
            True if the condition is satisfied within the timeout; otherwise, false
            </returns>
      <param name="condition">A delegate to be executed over and over until it returns true.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="sleepInMilliseconds">The amount of milliseconds the thread will sleep for.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="condition" /> argument is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</exception>
    </member>
    <member name="P:Cqrs.Infrastructure.SpinWait.NextSpinWillYield">
      <summary>
            Gets whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce" /> will yield the processor, triggering a forced context switch.
            </summary>
      <returns>
            Whether the next call to <see cref="M:System.Threading.SpinWait.SpinOnce" /> will yield the processor, triggering a forced context switch.
            </returns>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.System#Collections#IEnumerable#GetEnumerator">
      <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
      <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Add(`0)">
      <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Clear">
      <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Contains(`0)">
      <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.CopyTo(`0[],System.Int32)">
      <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1" /> to an <see cref="T:System.Array" />, starting at a particular <see cref="T:System.Array" /> index.
            </summary>
      <param name="array">The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1" />. The <see cref="T:System.Array" /> must have zero-based indexing.</param>
      <param name="arrayIndex">The zero-based index in <paramref name="array" /> at which copying begins.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="array" /> is null.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="arrayIndex" /> is less than 0.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="array" /> is multidimensional.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1" /> is greater than the available space from <paramref name="arrayIndex" /> to the end of the destination <paramref name="array" />.-or-Type <paramref name="TEntity" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</exception>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Remove(`0)">
      <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <returns>
            true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
      <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.IndexOf(`0)">
      <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Insert(System.Int32,`0)">
      <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.RemoveAt(System.Int32)">
      <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="P:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Count">
      <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
    </member>
    <member name="P:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
      <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.
            </returns>
    </member>
    <member name="P:Cqrs.Repositories.InMemoryDatabase.CollectionWrapper`1.Item(System.Int32)">
      <summary>
            Gets or sets the element at the specified index.
            </summary>
      <returns>
            The element at the specified index.
            </returns>
      <param name="index">The zero-based index of the element to get or set.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:Cqrs.Repositories.IRepository`2.Delete(`1)">
      <summary>
            Will mark the <paramref name="data" /> as logically (or soft).
            </summary>
    </member>
    <member name="M:Cqrs.Repositories.Queries.QueryParameter.CompareTo(System.Object)">
      <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
      <returns>
            A value that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj" />. Zero This instance is equal to <paramref name="obj" />. Greater than zero This instance is greater than <paramref name="obj" />. 
            </returns>
      <param name="obj">An object to compare with this instance. </param>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance. </exception>
    </member>
    <member name="M:Cqrs.Repositories.Queries.QueryParameter.CompareTo(Cqrs.Repositories.Queries.QueryParameter)">
      <summary>
            Compares the current object with another object of the same type.
            </summary>
      <returns>
            A value that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other" /> parameter.Zero This object is equal to <paramref name="other" />. Greater than zero This object is greater than <paramref name="other" />. 
            </returns>
      <param name="other">An object to compare with this object.</param>
    </member>
    <member name="M:Cqrs.Repositories.Repository`3.Delete(`2)">
      <summary>
            Will mark the <paramref name="data" /> as logically (or soft).
            </summary>
    </member>
    <member name="T:Cqrs.Services.IServiceRequest`1">
      <summary>
            A request message envelope that holds authentication and correlation information used when making public API requests.
            </summary>
      <typeparam name="TAuthenticationToken">The <see cref="T:System.Type">type</see> of authentication token used.</typeparam>
    </member>
    <member name="P:Cqrs.Services.IServiceRequest`1.AuthenticationToken">
      <summary>
            The authentication token used to identify the requester.
            </summary>
    </member>
    <member name="P:Cqrs.Services.IServiceRequest`1.CorrelationId">
      <summary>
            The correlation id used to group together events and notifications.
            </summary>
    </member>
    <member name="T:Cqrs.Services.IServiceRequestWithData`2">
      <summary>
            A <see cref="T:Cqrs.Services.IServiceRequest`1">request message envelope</see> that holds authentication, correlation information as well as request data used when making public API requests.
            </summary>
      <typeparam name="TAuthenticationToken">The <see cref="T:System.Type">type</see> of authentication token used.</typeparam>
      <typeparam name="TData">The <see cref="T:System.Type">type</see> of data sent along with the request to act upon/with.</typeparam>
    </member>
    <member name="P:Cqrs.Services.IServiceRequestWithData`2.Data">
      <summary>
            The data sent along with the request to act upon/with.
            </summary>
    </member>
    <member name="T:Cqrs.Services.IServiceResponse">
      <summary>
            A response message envelope that holds request state and correlation information in response to using public API requests.
            </summary>
    </member>
    <member name="P:Cqrs.Services.IServiceResponse.State">
      <summary>
            The state of the request.
            </summary>
    </member>
    <member name="P:Cqrs.Services.IServiceResponse.CorrelationId">
      <summary>
            The correlation id used to group together events and notifications.
            </summary>
    </member>
    <member name="T:Cqrs.Services.IServiceResponseWithResultData`1">
      <summary>
            A <see cref="T:Cqrs.Services.IServiceResponse">response message envelope</see> that holds request state, correlation information as well as the response data returned from making a public API request.
            </summary>
      <typeparam name="TResultData">The <see cref="T:System.Type">type</see> of data returned from making a public API request.</typeparam>
    </member>
    <member name="P:Cqrs.Services.IServiceResponseWithResultData`1.ResultData">
      <summary>
            The data returned from making a public API request.
            </summary>
    </member>
    <member name="M:Cqrs.Services.IUnitOfWorkService.SetCommitter(System.Object)">
      <summary>
            Informs the service of the object that will be committing the UnitOfWork.
            </summary>
      <returns>
            true if the provided <paramref name="commiter" /> is accepted as the committer, false otherwise.
            </returns>
    </member>
    <member name="M:Cqrs.Services.IUnitOfWorkService.Commit(System.Object)">
      <summary>
            Commits the UnitOfWork if the provided <paramref name="commiter" /> is the Committer.
            </summary>
      <returns>
            true if the provided <paramref name="commiter" /> is the Committer, false otherwise.
            </returns>
    </member>
    <member name="M:Cqrs.Services.ServiceChannelFactory`1.#ctor(System.String)">
      <summary>
            Instanciates a new instance of the <see cref="T:Cqrs.Services.ServiceChannelFactory`1" /> class with a specified endpoint configuration name.
            </summary>
      <param name="endpointConfigurationName">The configuration name used for the endpoint.</param>
    </member>
    <member name="T:Cqrs.Services.ServiceParameterResolver`2">
      <summary>
            A <see cref="T:System.Runtime.Serialization.DataContractResolver" /> for use via WCF
            </summary>
    </member>
    <member name="M:Cqrs.Services.ServiceParameterResolver`2.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
      <summary>
            Override this method to map the specified xsi:type name and namespace to a data contract type during deserialization.
            </summary>
      <returns>
            The type the xsi:type name and namespace is mapped to. 
            </returns>
      <param name="typeName">The xsi:type name to map.</param>
      <param name="typeNamespace">The xsi:type namespace to map.</param>
      <param name="declaredType">The type declared in the data contract.</param>
      <param name="knownTypeResolver">The known type resolver.</param>
    </member>
    <member name="M:Cqrs.Services.UnitOfWorkService`1.SetCommitter(System.Object)">
      <summary>
            Informs the service of the object that will be committing the <see cref="P:Cqrs.Services.UnitOfWorkService`1.UnitOfWork" />.
            </summary>
      <returns>
            true if the provided <paramref name="commiter" /> is accepted as the committer, false otherwise.
            </returns>
    </member>
    <member name="M:Cqrs.Services.UnitOfWorkService`1.Commit(System.Object)">
      <summary>
            Commits the <see cref="P:Cqrs.Services.UnitOfWorkService`1.UnitOfWork" /> if the provided <paramref name="commiter" /> is the <see cref="P:Cqrs.Services.UnitOfWorkService`1.Committer" />.
            </summary>
      <returns>
            true if the provided <paramref name="commiter" /> is the <see cref="P:Cqrs.Services.UnitOfWorkService`1.Committer" />, false otherwise.
            </returns>
    </member>
    <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /></summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Int32,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /> or exits if the specified timeout is expired.
            </summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /> or exits if the specified timeout is expired.
            </summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits until the specified condition is satisfied an event of <typeparamref name="TEvent" /></summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent" /> that is desired, return null to keep trying.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.Int32,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /> or exits if the specified timeout is expired.
            </summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent" /> that is desired, return null to keep trying.</param>
      <param name="millisecondsTimeout">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Bus.InProcessBus`1.SendAndWait``2(``0,System.Func{System.Collections.Generic.IEnumerable{Cqrs.Events.IEvent{`0}},``1},System.TimeSpan,Cqrs.Events.IEventReceiver{`0})">
      <summary>
            Sends the provided <paramref name="command" /> and waits for an event of <typeparamref name="TEvent" /> or exits if the specified timeout is expired.
            </summary>
      <param name="command">The <typeparamref name="TCommand" /> to send.</param>
      <param name="condition">A delegate to be executed over and over until it returns the <typeparamref name="TEvent" /> that is desired, return null to keep trying.</param>
      <param name="timeout">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
      <param name="eventReceiver">If provided, is the <see cref="T:Cqrs.Events.IEventReceiver`1" /> that the event is expected to be returned on.</param>
    </member>
    <member name="M:Cqrs.Bus.InProcessBus`1.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)">
      <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
    </member>
    <member name="M:Cqrs.Bus.InProcessBus`1.RegisterHandler``1(System.Action{``0},System.Boolean)">
      <summary>
            Register an event or command handler that will listen and respond to events or commands.
            </summary>
    </member>
    <member name="T:Cqrs.Snapshots.DefaultSnapshotStrategy`1">
      <summary>
            An <see cref="T:Cqrs.Snapshots.ISnapshotStrategy`1" /> that takes a snapshot every 15 versions
            </summary>
      <typeparam name="TAuthenticationToken" />
    </member>
    <member name="T:Cqrs.Configuration.BusRegistrar">
      <summary>
            Triggers the <see cref="T:Cqrs.Bus.IEventHandlerRegistrar" /> and <see cref="T:Cqrs.Bus.ICommandHandlerRegistrar" /> if they are registered in the <see cref="T:Cqrs.Configuration.IDependencyResolver" />.
            </summary>
    </member>
    <member name="M:Cqrs.Configuration.BusRegistrar.InvokeHandler(System.Type,Cqrs.Bus.IHandlerRegistrar,System.Func{System.Type,System.Collections.Generic.IEnumerable{System.Type}},System.Type)">
      <summary>
            Extract the <see cref="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)" /> method from the provided <paramref name="bus" />
            Create an <see cref="T:System.Action" /> around the provided <paramref name="executorType" />
            Then register the created <see cref="T:System.Action" /> using the extracted <see cref="M:Cqrs.Bus.IHandlerRegistrar.RegisterHandler``1(System.Action{``0},System.Type,System.Boolean)" /> method
            </summary>
      <param name="executorType">The <see cref="T:System.Type" /> of the event handler that will do the handling</param>
    </member>
  </members>
  <assembly>
    <name>HelloWorld</name>
  </assembly>
  <members>
    <member name="M:HelloWorld.Domain.Akka.Events.ConversationEnded.#ctor(System.Guid,System.String)">
      <summary>
            Instantiate a new instance of the <see cref="T:HelloWorld.Domain.Akka.Events.ConversationEnded" /> class
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.ConversationEnded.Id">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.ConversationEnded.Version">
      <summary>
            The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> shifted to as a result of the request.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.ConversationEnded.TimeStamp">
      <summary>
            The time the event was generated. Application of the event may happen at a different time.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.ConversationEnded.AuthenticationToken">
      <summary>
            The authentication token used to identify the requester.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.ConversationEnded.CorrelationId">
      <summary>
            The correlation id used to group together events and notifications.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.ConversationEnded.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.ConversationEnded.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.ConversationEnded.Rsn">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo.#ctor(System.Guid,System.String,System.String)">
      <summary>
            Instantiate a new instance of the <see cref="T:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo" /> class
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo.Id">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo.Version">
      <summary>
            The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> shifted to as a result of the request.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo.TimeStamp">
      <summary>
            The time the event was generated. Application of the event may happen at a different time.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo.AuthenticationToken">
      <summary>
            The authentication token used to identify the requester.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo.CorrelationId">
      <summary>
            The correlation id used to group together events and notifications.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo.Rsn">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Events.HelloWorldSaid.#ctor(System.Guid,System.String,System.String)">
      <summary>
            Instantiate a new instance of the <see cref="T:HelloWorld.Domain.Akka.Events.HelloWorldSaid" /> class
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldSaid.Id">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldSaid.Version">
      <summary>
            The version number the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> shifted to as a result of the request.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldSaid.TimeStamp">
      <summary>
            The time the event was generated. Application of the event may happen at a different time.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldSaid.AuthenticationToken">
      <summary>
            The authentication token used to identify the requester.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldSaid.CorrelationId">
      <summary>
            The correlation id used to group together events and notifications.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldSaid.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldSaid.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Events.HelloWorldSaid.Rsn">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Akka.Services.HelloWorldExampleServiceSayHelloWorldParametersResolver">
      <summary>
            A <see cref="T:System.Runtime.Serialization.DataContractResolver" /> for using <see cref="M:HelloWorld.Domain.Akka.Services.IHelloWorldExampleService.SayHelloWorld(Cqrs.Services.IServiceRequestWithData{Cqrs.Authentication.SingleSignOnToken,HelloWorld.Domain.Akka.Services.HelloWorldExampleSayHelloWorldParameters})" /> via WCF
            </summary>
      <summary>
            A <see cref="T:System.Runtime.Serialization.DataContractResolver" /> for using <see cref="M:HelloWorld.Domain.Akka.Services.IHelloWorldExampleService.SayHelloWorld(Cqrs.Services.IServiceRequestWithData{Cqrs.Authentication.SingleSignOnToken,HelloWorld.Domain.Akka.Services.HelloWorldExampleSayHelloWorldParameters})" /> via WCF
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Services.HelloWorldExampleServiceSayHelloWorldParametersResolver.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
      <summary>
            Override this method to map the specified xsi:type name and namespace to a data contract type during deserialization.
            </summary>
      <returns>
            The type the xsi:type name and namespace is mapped to. 
            </returns>
      <param name="typeName">The xsi:type name to map.</param>
      <param name="typeNamespace">The xsi:type namespace to map.</param>
      <param name="declaredType">The type declared in the data contract.</param>
      <param name="knownTypeResolver">The known type resolver.</param>
    </member>
    <member name="T:HelloWorld.Domain.Akka.Services.HelloWorldExampleServiceReplyToHelloWorldParametersResolver">
      <summary>
            A <see cref="T:System.Runtime.Serialization.DataContractResolver" /> for using <see cref="M:HelloWorld.Domain.Akka.Services.IHelloWorldExampleService.ReplyToHelloWorld(Cqrs.Services.IServiceRequestWithData{Cqrs.Authentication.SingleSignOnToken,HelloWorld.Domain.Akka.Services.HelloWorldExampleReplyToHelloWorldParameters})" /> via WCF
            </summary>
      <summary>
            A <see cref="T:System.Runtime.Serialization.DataContractResolver" /> for using <see cref="M:HelloWorld.Domain.Akka.Services.IHelloWorldExampleService.ReplyToHelloWorld(Cqrs.Services.IServiceRequestWithData{Cqrs.Authentication.SingleSignOnToken,HelloWorld.Domain.Akka.Services.HelloWorldExampleReplyToHelloWorldParameters})" /> via WCF
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Services.HelloWorldExampleServiceReplyToHelloWorldParametersResolver.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
      <summary>
            Override this method to map the specified xsi:type name and namespace to a data contract type during deserialization.
            </summary>
      <returns>
            The type the xsi:type name and namespace is mapped to. 
            </returns>
      <param name="typeName">The xsi:type name to map.</param>
      <param name="typeNamespace">The xsi:type namespace to map.</param>
      <param name="declaredType">The type declared in the data contract.</param>
      <param name="knownTypeResolver">The known type resolver.</param>
    </member>
    <member name="T:HelloWorld.Domain.Akka.Services.HelloWorldExampleServiceEndConversationParametersResolver">
      <summary>
            A <see cref="T:System.Runtime.Serialization.DataContractResolver" /> for using <see cref="M:HelloWorld.Domain.Akka.Services.IHelloWorldExampleService.EndConversation(Cqrs.Services.IServiceRequestWithData{Cqrs.Authentication.SingleSignOnToken,HelloWorld.Domain.Akka.Services.HelloWorldExampleEndConversationParameters})" /> via WCF
            </summary>
      <summary>
            A <see cref="T:System.Runtime.Serialization.DataContractResolver" /> for using <see cref="M:HelloWorld.Domain.Akka.Services.IHelloWorldExampleService.EndConversation(Cqrs.Services.IServiceRequestWithData{Cqrs.Authentication.SingleSignOnToken,HelloWorld.Domain.Akka.Services.HelloWorldExampleEndConversationParameters})" /> via WCF
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Services.HelloWorldExampleServiceEndConversationParametersResolver.ResolveName(System.String,System.String,System.Type,System.Runtime.Serialization.DataContractResolver)">
      <summary>
            Override this method to map the specified xsi:type name and namespace to a data contract type during deserialization.
            </summary>
      <returns>
            The type the xsi:type name and namespace is mapped to. 
            </returns>
      <param name="typeName">The xsi:type name to map.</param>
      <param name="typeNamespace">The xsi:type namespace to map.</param>
      <param name="declaredType">The type declared in the data contract.</param>
      <param name="knownTypeResolver">The known type resolver.</param>
    </member>
    <member name="T:HelloWorld.Domain.Akka.Services.HelloWorldExampleSayHelloWorldParameters">
      <summary>
            The parameters for the <see cref="M:HelloWorld.Domain.Akka.Services.IHelloWorldExampleService.SayHelloWorld(Cqrs.Services.IServiceRequestWithData{Cqrs.Authentication.SingleSignOnToken,HelloWorld.Domain.Akka.Services.HelloWorldExampleSayHelloWorldParameters})" /> method.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Akka.Services.HelloWorldExampleReplyToHelloWorldParameters">
      <summary>
            The parameters for the <see cref="M:HelloWorld.Domain.Akka.Services.IHelloWorldExampleService.ReplyToHelloWorld(Cqrs.Services.IServiceRequestWithData{Cqrs.Authentication.SingleSignOnToken,HelloWorld.Domain.Akka.Services.HelloWorldExampleReplyToHelloWorldParameters})" /> method.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Akka.Services.HelloWorldExampleEndConversationParameters">
      <summary>
            The parameters for the <see cref="M:HelloWorld.Domain.Akka.Services.IHelloWorldExampleService.EndConversation(Cqrs.Services.IServiceRequestWithData{Cqrs.Authentication.SingleSignOnToken,HelloWorld.Domain.Akka.Services.HelloWorldExampleEndConversationParameters})" /> method.
            </summary>
    </member>
  </members>
  <assembly>
    <name>HelloWorld.Domain</name>
  </assembly>
  <members>
    <member name="M:HelloWorld.Domain.Akka.Commands.EndConversationCommand.#ctor(System.Guid,System.String)">
      <summary>
            Instantiate a new instance of the <see cref="T:HelloWorld.Domain.Akka.Commands.EndConversationCommand" /> class
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.EndConversationCommand.Id">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.EndConversationCommand.ExpectedVersion">
      <summary>
            The version number you expect this command to shift the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> to. I.E. +1 from what you know it's current version to be.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.EndConversationCommand.AuthenticationToken">
      <summary>
            The authentication token used to identify the requester.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.EndConversationCommand.CorrelationId">
      <summary>
            The correlation id used to group together events and notifications.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.EndConversationCommand.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.EndConversationCommand.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.EndConversationCommand.Rsn">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Commands.Handlers.EndConversationCommandHandler.#ctor(Cqrs.Akka.Domain.IAkkaAggregateResolver,Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger)">
      <summary>
            Instantiates the <see cref="T:HelloWorld.Domain.Akka.Commands.Handlers.EndConversationCommandHandler" /> class registering any <see cref="!:ReceiveActor.Receive&lt;T&gt;(System.Func&lt;T,System.Threading.Tasks.Task&gt;)" /> required.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Commands.Handlers.ReplyToHelloWorldCommandHandler.#ctor(Cqrs.Akka.Domain.IAkkaAggregateResolver,Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger)">
      <summary>
            Instantiates the <see cref="T:HelloWorld.Domain.Akka.Commands.Handlers.ReplyToHelloWorldCommandHandler" /> class registering any <see cref="!:ReceiveActor.Receive&lt;T&gt;(System.Func&lt;T,System.Threading.Tasks.Task&gt;)" /> required.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Commands.Handlers.SayHelloWorldCommandHandler.#ctor(Cqrs.Akka.Domain.IAkkaAggregateResolver,Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger)">
      <summary>
            Instantiates the <see cref="T:HelloWorld.Domain.Akka.Commands.Handlers.SayHelloWorldCommandHandler" /> class registering any <see cref="!:ReceiveActor.Receive&lt;T&gt;(System.Func&lt;T,System.Threading.Tasks.Task&gt;)" /> required.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand.#ctor(System.Guid,System.String)">
      <summary>
            Instantiate a new instance of the <see cref="T:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand" /> class
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand.Id">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand.ExpectedVersion">
      <summary>
            The version number you expect this command to shift the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> to. I.E. +1 from what you know it's current version to be.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand.AuthenticationToken">
      <summary>
            The authentication token used to identify the requester.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand.CorrelationId">
      <summary>
            The correlation id used to group together events and notifications.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand.Rsn">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Commands.SayHelloWorldCommand.#ctor(System.Guid,System.String)">
      <summary>
            Instantiate a new instance of the <see cref="T:HelloWorld.Domain.Akka.Commands.SayHelloWorldCommand" /> class
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.SayHelloWorldCommand.Id">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.SayHelloWorldCommand.ExpectedVersion">
      <summary>
            The version number you expect this command to shift the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> to. I.E. +1 from what you know it's current version to be.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.SayHelloWorldCommand.AuthenticationToken">
      <summary>
            The authentication token used to identify the requester.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.SayHelloWorldCommand.CorrelationId">
      <summary>
            The correlation id used to group together events and notifications.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.SayHelloWorldCommand.OriginatingFramework">
      <summary>
            The originating framework this message was sent from.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.SayHelloWorldCommand.Frameworks">
      <summary>
            The frameworks this <see cref="T:Cqrs.Messages.IMessage" /> has been delivered to/sent via already.
            </summary>
    </member>
    <member name="P:HelloWorld.Domain.Akka.Commands.SayHelloWorldCommand.Rsn">
      <summary>
            The Rsn of the <see cref="T:Cqrs.Domain.IAggregateRoot`1">aggregate</see> being targeted.
            </summary>
    </member>
    <member name="T:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldRepliedToToEndConversationEventToCommandHandler">
      <summary>
            Converts <see cref="T:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo" /> to a <see cref="T:HelloWorld.Domain.Akka.Commands.EndConversationCommand" /> and publish it using <see cref="!:CommandBus" /></summary>
      <summary>
            Converts <see cref="T:HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo" /> to a <see cref="T:HelloWorld.Domain.Akka.Commands.EndConversationCommand" /> and publish it using <see cref="!:CommandBus" /></summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldRepliedToToEndConversationEventToCommandHandler.#ctor(cdmdotnet.Logging.ILogger,cdmdotnet.AutoMapper.IAutomapHelper)">
      <summary>
            Instantiates the <see cref="T:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldRepliedToToEndConversationEventToCommandHandler" /> class.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldRepliedToToEndConversationEventToCommandHandler.#ctor(Cqrs.Akka.Domain.IAkkaAggregateResolver,cdmdotnet.Logging.ILogger,cdmdotnet.AutoMapper.IAutomapHelper)">
      <summary>
            Instantiates the <see cref="T:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldRepliedToToEndConversationEventToCommandHandler" /> class registering any <see cref="M:Akka.Actor.ReceiveActor.Receive``1(System.Func{``0,System.Threading.Tasks.Task})" /> required.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldRepliedToToEndConversationEventToCommandHandler.Actor.Handle(HelloWorld.Domain.Akka.Events.HelloWorldRepliedTo)">
      <summary>
            Convert the provided <paramref name="@event" /> to a <see cref="T:HelloWorld.Domain.Akka.Commands.EndConversationCommand" /> and publish it using <see cref="P:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldRepliedToToEndConversationEventToCommandHandler.Actor.CommandBus" /></summary>
    </member>
    <member name="T:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldSaidToReplyToHelloWorldEventToCommandHandler">
      <summary>
            Converts <see cref="T:HelloWorld.Domain.Akka.Events.HelloWorldSaid" /> to a <see cref="T:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand" /> and publish it using <see cref="P:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldSaidToReplyToHelloWorldEventToCommandHandler.CommandBus" /></summary>
      <summary>
            Converts <see cref="T:HelloWorld.Domain.Akka.Events.HelloWorldSaid" /> to a <see cref="T:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand" /> and publish it using <see cref="P:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldSaidToReplyToHelloWorldEventToCommandHandler.CommandBus" /></summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldSaidToReplyToHelloWorldEventToCommandHandler.#ctor(cdmdotnet.Logging.ILogger,cdmdotnet.AutoMapper.IAutomapHelper)">
      <summary>
            Instantiates the <see cref="T:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldSaidToReplyToHelloWorldEventToCommandHandler" /> class.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldSaidToReplyToHelloWorldEventToCommandHandler.#ctor(Cqrs.Akka.Commands.IAkkaCommandSender{Cqrs.Authentication.SingleSignOnToken},cdmdotnet.Logging.ILogger,cdmdotnet.AutoMapper.IAutomapHelper)">
      <summary>
            Instantiates the <see cref="T:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldSaidToReplyToHelloWorldEventToCommandHandler" /> class.
            </summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldSaidToReplyToHelloWorldEventToCommandHandler.Handle(HelloWorld.Domain.Akka.Events.HelloWorldSaid)">
      <summary>
            Convert the provided <paramref name="@event" /> to a <see cref="T:HelloWorld.Domain.Akka.Commands.ReplyToHelloWorldCommand" /> and publish it using <see cref="P:HelloWorld.Domain.Akka.Events.Handlers.HelloWorldSaidToReplyToHelloWorldEventToCommandHandler.CommandBus" /></summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.HelloWorldExample.#ctor">
      <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory" /></summary>
    </member>
    <member name="M:HelloWorld.Domain.Akka.HelloWorldExample.#ctor(Cqrs.Configuration.IDependencyResolver,cdmdotnet.Logging.ILogger)">
      <summary>
            A constructor for the <see cref="T:Cqrs.Domain.Factories.IAggregateFactory" /></summary>
    </member>
  </members>
</doc>